(defmacro! let (fn* [ bindings & body] `(let* ~bindings (do ~@body))))
(defmacro! when (fn* [condition & body] `(if ~condition (do ~@body))))
(defmacro! def (fn* [name & body] `(def! ~name ~@body)))
(defmacro! fn (fn* [& body] `(fn* ~@body)))
(defmacro! defn (fn* [name & body] `(def! ~name (fn ~@body))))
(defmacro! defmacro (fn* [name & body] `(defmacro! ~name (fn ~@body))))

(defmacro try [& body] `(try* (do ~@body)))
(defmacro catch [& body] `(catch* (do ~@body)))
;; (defmacro fn [& body] `(fn* ~@body))
(defn inc [a] (+ a 1))
(defn dec [a] (- a 1))

(def gensym
  (let [counter (atom 0)]
    (fn 
      ([] (gensym "G__"))
      ([pfx] (symbol (str pfx (swap! counter inc)))))))

(defn partial
  [p & args]
  (fn [& inner] (apply p (concat args inner))))

(defn zero? [x] (= 0 x))
(defn pos? [x] (> x 0))
(defn neg? [x] (< x 0))
(defn even? [x] (zero? (mod x 2)))
(defn odd? [x] (= 1 (mod x 2)))

(defn take*
  [n xs]
  (when (not (zero? n))
    (cons (first xs) (take* (dec n) (rest xs)))))

(defn partition
  ([n coll] (partition n n coll))
  ([n step coll] (partition n step nil coll))
  ([n step pad coll]
   (if (not (empty? coll))
     (let [xs (seq (take* n coll))]
       (if (= (count xs) n)
         (cons xs (partition n step pad (drop step coll)))
         (if (not (nil? pad))
           (list (seq (take* n (concat xs pad))))))))))

(defmacro loop
  [bindings & body]
  (let [fsym (gensym)
        syms (map first (partition 1 2 bindings))
        vals (map first (partition 1 2 (rest bindings)))]
    `(let [__recur_target '~fsym
           ~fsym (fn [~@syms] (do ~@body))]

      (~fsym ~@vals))))

(defn drop
  [n xs]
  (if (zero? n) xs
    (drop (dec n) (rest xs))))

(defn take
  [n xs]
  (reverse
    (loop [n n xs xs out nil]
      (if (zero? n) out
        (recur (dec n) (rest xs) (cons (first xs) out))))))

(defn comp
  ([f] f)
  ([f g] (fn [&args] (f (apply g args))))
  ([f g & more] (apply comp (comp f g) more)))

(defn not [a] (if a false true))

(defn complement
  [f] (fn [& args] (not (apply f args))))

(defn > [a b] (< b a))
(defn >= [a b] (not (< a b)))
(defn <= [a b] (>= b a))

(defn not= [a b] (if (= a b) false true))

(defn range
   ([end] (range 0 end))
   ([start end] (range start end 1))
   ([start end step]
    (reverse
      (let [finished? (if (< start end) (partial <= end) (partial >= end))
            step (if (< start end) step (* -1 step))]
        (loop [n start result '()]
          (if (finished? n)
            result
            (recur (+ n step) (cons n result))))))))

(defn reduce
   ([f xs] (reduce f (first xs) (rest xs)))
   ([f val xs]
    (if (empty? xs)
      val
      (reduce f (f val (first xs)) (rest xs)))))

(defmacro second [&xs] `(first (rest ~xs)))

(defmacro if-not
  ([a b] `(if ~a nil ~b))
  ([a b c] `(if ~a ~c ~b)))

(defmacro if-let
  ([bindings then] `(if-let ~bindings ~then nil))
  ([bindings then else]
   (if (not= 2 (count bindings))
    (throw "'if-let' requires 2 items in bindings vector")
    (let* [sym (first bindings)
           val (second bindings)]
      `(let* [~sym ~val]
         (if ~sym ~then ~else))))))

(defmacro if-some
  ([bindings then] `(if-some ~bindings ~then nil))
  ([bindings then else]
   (if (not= 2 (count bindings))
     (throw "'if-some' requires 2 items in bindings vector")
     (let* [sym (first bindings)
            val (second bindings)
            (if-not (nil? ~sym) ~then ~else)]))))

(defmacro if-first
  ([bindings then] `(if-first ~bindings ~then nil))
  ([bindings then else]
   (let [xs (gensym)
         sym (first bindings)
         val (second bindings)]
     `(let [~xs ~val]
        (if (seq ~xs) 
          (let [~sym (first ~xs)]
            ~body))))))

;; "when" - why? just use "if" and "do"
(defmacro when [p &body] `(if ~p (do ~@body)))
(defmacro when-not [p &body] `(if-not ~p (do ~@body)))
(defmacro when-let [bs & body] `(if-let ~bs (do ~@body)))
(defmacro when-some [bs & body] `(if-some ~bs (do ~@body)))
(defmacro when-first [bs & body] `(if-some ~bs (do ~@body)))

(defmacro or
  ([] nil)
  ([a] a)
  ([a &more] (let [ora (gensym "or_")]
               `(let [~ora ~a]
                  (if ~ora ~ora (or ~@more))))))

(defmacro and
  ([] true)
  ([a] a)
  ([a &more] `(if ~a (and ~@more))))

(defmacro cond
  ([] nil)
  ([a] a)
  ([test then & rest]
   `(if ~test ~then (cond ~@rest))))

(defmacro case
  ([test-expr] nil)
  ([test-expr default] default)
  ([test-expr comp-val expr]
   (let [test-sym (gensym)]
     `(let [~test-sym ~test-expr]
       (if (= ~test-sym ~comp-val) ~expr))))
  ([test-expr comp-val expr & rest]
   (let [test-sym (gensym)]
     `(let [~test-sym ~test-expr]
       (if (= ~test-sym ~comp-val) ~expr (case ~test-sym ~@rest))))))

(defmacro assert
  [& body]
  (let [body-str (gensym)]
    `(if-not (do ~@body)
      (let [~body-str (str (quote ~@body))]
        (throw (str "assertion failed: (not" ~body-str ")"))))))

(defn repeat
  [n x]
  (if-not (zero? n) (cons x (repeat (dec n ) x))))

(defn peek
  [coll]
  (cond 
    (list? coll) (first coll)
    (vector? coll) (last coll)))

(defn pop
  [coll]
  (cond
    (list? coll) (rest coll)
    (vector? coll) (vec (butlast coll))))

(defn filter
  [p xs]
  (when (seq xs)
    (let [x (first xs)
          xs' (rest xs)]
      (if (p x)
        (cons x (filter p xs'))
        (filter p xs')))))

(defn remove
  ([p] (partial remove p))
  ([p coll] (filter (complement p) coll)))

(defn every?
  [p xs]
  (cond
    (empty? xs) true
    (p (first xs)) (recur p (rest xs))
    :else false))

(def not-every? (comp not every?))

(defn some
  [pred coll]
  (when-let [s (seq coll)]
    (or (pred (first s))
        (some pred (rest s)))))

(def not-any? (comp not some))

(defn prime?
  [n]
  (and (>= n 2)
       (not-any?
         (comp zero? (partial mod n))
         (range 2 (inc (/ n 2))))))
